/*
	그래프
	-객체간의 연결 관계를 표현 할 수 있는 비선형 자료구조
	-'쾨니히스베르크의 다리문제(한붓그리기, 오일러경로)'가 그래프의 시초
	- 예시 : 지도에서 도시들의연결, 지하철 노선도, SNS친구관계 ...

	그래프의 구성 요소
		
		그래프 G = (V, E)

	- 정점 V : 그래프를 구성하는 기본단위, 노드.
			   자료를 저장하거나 상태를 표현

	- 엣지 E : 정점과 정점을 잇는 선, 간선.
			   방향을 가질 수 있고, 가중치를 가질 수 있음

	그래프 용어
	- 가중치 : 에지에 부여된 수치. 비용(cost)
	- 인접정점: 에지로 연결되어 있는 정점
	- 차수(degree): 정점에 연결된 다른 정점의 개수
	- 경로: 특정 정점에서 다른 정점으로 이동하는 방법을 인접정점의 나열로 표헌한 것
	- 사이클: 시작 정점과 마지막이 같은 단순 경로
			 (트리는 사이클이 없는 그래프라고도 한다)

    - 방향그래프: 에지에 방향이 있는 그래프. 유향그래프, 네트워크
				 방향그래프에서 엣지(u,v)는 정점(u)에서 정점(v)로 이동하는 
				 에지를 나타냄. (u,v) != (v,u)
				 * 화살표 표시가 없으면 양방향그래프임*
				 
	- 가중치 그래프: 엣지에 가중치가 부여 되어 있는 그래프

	- 서브 그래프: 주어진 그래프에서 정점과 간선 일부를 제외하여 만든 그래프. 부분그래프.

	* 인접 행렬
		- 정점 개수가 N인 경우, N*N크기의 2차원 행열로 정점의 인접관계를 표현하는 방법
		- adg[u][v]: 노드 u에서 노드 v로 가는 간선이 있으면 1, 아니면 0
		- 그래프 정점개수가 적고, 엣지가 많을 때 유리하다
		- 공간복잡도 O(N2) N은 정점의 개수

		0 -	1							0	1	2	3
		| \			=> 4*4 행렬       0 0	1	1	1
		2 -	3						  
									  1 1	0	0	0
		* 0과 1 , 2 ,3 이 연결이면
		 행렬에 1표시				  2 1	0	0	1

									  3 1	0	1	0

		* 방향그래프는 방향대로 연결되어잇는부분만 행렬 표시
		

	* 인접 리스트
		- 각 정점에 인접한 정점들을 연결리스트로 표현
		- 보통 정점 개수에 해당하는 배열의 각 원소에 연결리스트가 속해 있는 형태로 표현
		- 공간 복잡도는 O(N+M) (N: 정점개수, M: 엣지개수)

		0 -	1				0 -> 1 -> 2 -> 3
		| \			=>		1 -> 0 -> null
		2 -	3				2 -> 0 -> 3 -> null
							3 -> 0 -> 2 -> null
		
		* 방향그래프는 방향대로 연결되어잇는부분만 리스트 표시
	

*/							

//#include <iostream>
//#include <vector>
//
//using namespace std;
//
//vector<vector<int>> get_adj_list(const vector<vector<int>>& adj_matrix)
//{
//	vector<vector<int>> adj_list(adj_matrix.size());
//
//	for (int u = 0; u < adj_matrix.size(); u++)
//	{
//		for (int v = 0; v < adj_matrix[u].size(); v++)
//		{
//			if (adj_matrix[u][v] == 1)
//			{
//				adj_list[u].push_back(v);
//			}
//		}
//	}
//}
//
//int main()
//{
//	//인접행렬 코드
//	vector<vector<int>> adt_matrix = {
//		{ 0, 1, 0, 1, 1, 0 },
//		{ 1, 0, 1, 0, 1, 0 },
//		{ 0, 1, 0, 0, 0, 1 },
//		{ 1, 0, 0, 0, 1, 0 },
//		{ 1, 1, 0, 1, 0, 0 },
//		{ 0, 0, 1, 0, 0, 0 }
//	};
//
//	vector<vector<int>>adg_list = {
//		{1,3,4},
//		{0,2,4},
//		{1,5},
//		{0,4},
//		{0,1,3},
//		{2}
//	}; //리스트를 사용하는것보다 벡터벡터가 좀더 많이 사용됨..
//
//	vector<vector<int>> edge_list = {
//		{0,1},{0,3},{0,4},
//		{1,0},{1,2},{1,4},
//		{2,1},{2,5},
//		{3,0},{3,4},
//		{4,0},{4,1},{4,3},
//		{5,2}
//	};
//
//	vector<vector<int>> adj_list = get_adj_list(adt_matrix);
//
//	for (const auto& l : adj_list)
//	{
//		for (const auto n : l)
//			cout << n << ", ";
//		cout << endl;
//	}
//
//}
